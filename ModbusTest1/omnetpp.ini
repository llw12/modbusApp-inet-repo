[General]
network = ModbusTest1
sim-time-limit = 20s

*.*.eth[*].bitrate = 100Mbps

*.numClients = 2

#define MODBUS_FC_READ_COILS               0x01
#define MODBUS_FC_READ_DISCRETE_INPUTS     0x02
#define MODBUS_FC_READ_HOLDING_REGISTERS   0x03
#define MODBUS_FC_READ_INPUT_REGISTERS     0x04
#define MODBUS_FC_WRITE_SINGLE_COIL        0x05
#define MODBUS_FC_WRITE_SINGLE_REGISTER    0x06
#define MODBUS_FC_READ_EXCEPTION_STATUS    0x07
#define MODBUS_FC_WRITE_MULTIPLE_COILS     0x0F
#define MODBUS_FC_WRITE_MULTIPLE_REGISTERS 0x10
#define MODBUS_FC_REPORT_SLAVE_ID          0x11
#define MODBUS_FC_MASK_WRITE_REGISTER      0x16
#define MODBUS_FC_WRITE_AND_READ_REGISTERS 0x17

*.operatorStation.numApps = 2
*.operatorStation.app[0].typename = "OperatorStationApp"
*.operatorStation.app[0].connectAddress = "server"
*.operatorStation.app[0].connectPort = 1000
*.operatorStation.app[0].interval = 0.5s

*.operatorStation.app[1].typename = "OperatorStationApp2"
*.operatorStation.app[1].connectAddress = "server"
*.operatorStation.app[1].connectPort = 666
#modbusRequest格式"主机名 从站Id 功能玛 起始地址 数量 数据"

## 地址超出范围（slave1线圈最大地址3，请求地址4）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 01 0004 0001"
## 数量超出范围（slave3第一个线圈组数量8，请求9）
#*.operatorStation.app[1].modbusRequest = "client[1] 03 01 0064 0009"
## 无效从站ID（不存在的slave4）
#*.operatorStation.app[1].modbusRequest = "client[1] 04 01 0000 0001"

## 读slave2的离散输入组（地址5-6，数量2）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 02 0005 0002"
## 地址超出范围（slave2离散输入最大地址6，请求地址7）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 02 0007 0001"
## 从站无离散输入（slave1的numInputBitGroup=0）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 02 0000 0001"

## 读slave1的保持寄存器（地址10-12，数量3）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 03 000A 0003"  # 10=0x0A
## 读slave1的保持寄存器全部10个（地址10-19）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 03 000A 000A"
## 地址超出范围（slave1寄存器最大地址19，请求地址20）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 03 0014 0001"  # 20=0x14
## 数量超出范围（请求11个，超出slave1的10个）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 03 000A 000B"
## 从站无保持寄存器（slave2的numRegisterGroup=0）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 03 0000 0001"

## 读slave2的输入寄存器（地址20-22，数量3）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 04 0014 0003"  # 20=0x14
## 读slave2的输入寄存器部分（地址20-21，数量2）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 04 0014 0002"
# 地址超出范围（slave2输入寄存器最大地址22，请求23）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 04 0017 0001"  # 23=0x17
## 从站无输入寄存器（slave1的numInputRegisterGroup=0）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 04 0000 0001"

## 写slave1的线圈地址0为OFF
#*.operatorStation.app[1].modbusRequest = "client[0] 01 05 0000 0001 00"
## 写slave3的线圈地址101为OFF
#*.operatorStation.app[1].modbusRequest = "client[1] 03 05 0065 0000"  # 101=0x65
## 地址超出范围（slave1线圈最大地址3，写地址4）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 05 0004 FF00"
## 从站无线圈（slave2的numBitGroup=0）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 05 0000 FF00"

## 写slave1的保持寄存器地址10为0x1234
#*.operatorStation.app[1].modbusRequest = "client[0] 01 06 000A 1234"  # 10=0x0A
## 写slave1的保持寄存器地址19为0x5678
#*.operatorStation.app[1].modbusRequest = "client[0] 01 06 0013 5678"  # 19=0x13
## 地址超出范围（slave1寄存器最大地址19，写地址20）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 06 0014 1234"  # 20=0x14
## 从站无保持寄存器（slave3的numRegisterGroup=0）
#*.operatorStation.app[1].modbusRequest = "client[1] 03 06 0000 1234"

## 写slave1的线圈地址0-3（4个）为1,0,0,1
#*.operatorStation.app[1].modbusRequest = "client[0] 01 0F 0000 0004 01 00 00 01"
## 写slave3的线圈地址200-201（2个）为0,1（数据字节0x02=00000010）
#*.operatorStation.app[1].modbusRequest = "client[1] 03 0F 00C8 0002 01 02"  # 200=0xC8
## 数量超出范围（slave1线圈共4个，写5个）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 0F 0000 0005 01 1F"
## 数据长度错误（写4个线圈需1字节数据，传2字节）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 0F 0000 0004 02 90 00"

## 写slave1的保持寄存器地址10-12（3个）为0x0001,0x0002,0x0003
#*.operatorStation.app[1].modbusRequest = "client[0] 01 10 000A 0003 06 00 01 00 02 00 03"  # 数据长度=3×2=6字节
## 写slave2的输入寄存器地址20-21（2个）为0x0064,0x00C8（100,200）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 10 0014 0002 04 00 64 00 C8"  # 20=0x14，数据长度=2×2=4字节
## 数量超出范围（slave2输入寄存器共3个，写4个）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 10 0014 0004 08 00 01 00 02 00 03 00 04"
## 数据长度错误（写2个寄存器需4字节数据，传3字节）
#*.operatorStation.app[1].modbusRequest = "client[0] 02 10 0014 0002 03 00 64 00"
## 从站无输入寄存器（slave3的numInputRegisterGroup=0）
#*.operatorStation.app[1].modbusRequest = "client[1] 03 10 0000 0001 02 00 01"

## 发送无效功能码（0x11，未定义）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 11 0000 0001"
## 读操作使用写功能码（对线圈使用0x03读寄存器功能码）
#*.operatorStation.app[1].modbusRequest = "client[0] 01 03 0000 0004"
##测试非寄存器起始地址开始写单个数据
#*.operatorStation.app[1].modbusRequest = "client[0] 01 06 000B 0001 00 0a"  
#测试非寄存器起始地址开始写多个数据
*.operatorStation.app[1].modbusRequest = "client[0] 01 10 000B 0009 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 08 00 09" 
*.operatorStation.app[1].sendTime = 4s

*.server.numApps = 3
*.server.app[0].typename = "ModbusMasterApp"  #app[0]必须为ModbusMasterApp，因为在ModbusTcpServerApp和TransitApp中需要通过^.app[0]获取ModbusMasterApp的实例化对象
*.server.app[0].numConnect = 2
*.server.app[0].configFile = "MasterConfig.json"  # 从站配置文件路径
*.server.app[0].readInterval = 0.5s                     # 定时读取间隔（1秒/次）

*.server.app[1].typename = "ModbusTcpServerApp"
*.server.app[1].localPort = 1000

*.server.app[2].typename = "TransitApp"
*.server.app[2].localPort = 666

**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535                      # 保持默认，需结合窗口缩放使用
**.tcp.delayedAcksEnabled = false                    # 保持禁用，避免ACK延迟
**.tcp.nagleEnabled = false                           # 禁用Nagle，加速小数据包传输
**.tcp.limitedTransmitEnabled = true                 # 启用有限传输，优化重传
**.tcp.increasedIWEnabled = true                     # 启用增大初始窗口，加速连接初期传输
**.tcp.sackSupport = true                            # 保持启用，减少无效重传
**.tcp.windowScalingSupport = true                   # 启用窗口缩放，突破64KB窗口限制
**.tcp.timestampSupport = true                       # 启用时间戳，优化RTT估算
**.tcp.mss = 1452                                    # 保持当前值，适配MTU
**.tcp.tcpAlgorithmClass = "TcpReno"              # 切换为TcpReno，提升丢包恢复性能

# misc settings
**.crcMode = "computed"
**.fcsMode = "computed"

# pcap recorder settings
*.server.numPcapRecorders = 1
*.server.pcapRecorder[*].pcapFile = "results/server.pcap"

# Visualizer settings
*.visualizer.interfaceTableVisualizer.displayInterfaceTables = true


[unHardInLoop]
*.client[*].numApps = 1
*.client[*].app[0].typename = "ModbusSlaveApp"
*.client[*].app[0].localPort = 502
*.client[*].app[0].slavesConfigPath = "SlaveConfig.json"


[HardInLoop]

scheduler-class = "inet::RealTimeScheduler"

*.client[0].numApps = 1
*.client[0].app[0].typename = "ModbusSlaveHILApp"
*.client[0].app[0].localPort = 502
*.client[0].app[0].remoteAddress = "192.168.43.203"
*.client[0].app[0].remotePort = 502


*.client[*].numApps = 1
*.client[*].app[0].typename = "ModbusSlaveApp"
*.client[*].app[0].localPort = 502
*.client[*].app[0].slavesConfigPath = "SlaveConfig.json"

#*.client[0].forwarding = true
#
#*.configurator.config = xml("<config> \
#                                <interface hosts='client[0]' names='eth2' address='192.168.74.10' netmask='255.255.255.0'/> \
#								<interface hosts='**' address='10.x.x.x' netmask='255.x.x.x'/> \
#								<route hosts='client0' destination='192.168.43.203' netmask='255.255.255.255' gateway='192.168.43.1' interface='eth2' metric='0'/> \
#                             </config>")
#
#*.**.ipv4.arp.typename = "Arp"
#
#*.client[0].numEthInterfaces = 3
#*.client[0].eth[2].typename = "ExtLowerEthernetInterface"
#*.client[0].eth[2].device = "ens33"
#*.client[0].eth[2].mtu = 1500B
#*.client[0].interfaceTable.displayAddresses = true
#*.client[0].eth[2].copyConfiguration = "copyFromExt"
#*.client[0].ipv4.arp.typename = "Arp"


